# musict

> music

## Build Setup

``` bash
# install dependencies
npm install

# serve with hot reload at localhost:8080
npm run dev

# build for production with minification
npm run build

# build for production and view the bundle analyzer report
npm run build --report
```

For a detailed explanation on how things work, check out the [guide](http://vuejs-templates.github.io/webpack/) and [docs for vue-loader](http://vuejs.github.io/vue-loader).
1/31日
 = =这个git的使用还不是很熟练 解决本地与远程文件出现冲突还是没法好好解决 git应该再回去看一看
 compnenets：recommend组件完成了基础的dom结构 //css方面 flex布局和rem布局需要注意 这个似乎并未做浏览器适配 
 common/js：jsonp文件 再封装了一个新的promise对象  //promise的写法有些遗忘 需要再回头看一下 jsonp的实现需要自己去封装一下
 config.js //ES6的AMD规范稍微忘了一些
 api:recommend.js //object.assgin的含义是？
 2/1日
 首先是封装了一个基础的dom操作 添加样式 在添加样式前应检测这个样式是否存在 这里使用了正则表达式
 再就是循环输出接口的数据 这里的数据处理异步函数的jsonp
 新的滚动库 better-scroll可以去看看api 然后就是注意使用组件时 插槽组件的钩子函数可能是执行完之后
 才会去渲染插槽里的内容 就会使得钩子函数无效 因为获取数据这里是个异步的过程 所以要用v-if判定一下
 数据是否接收到 跟上面的非空检测是一样的内容
 这个老师还有个课程也可以去看看
 2/9日
 教程涉及的步骤点 步骤之后的目的  衍生的内容 XMind要写一份思维导图 第四章结束后小小总结一下
 4-7：优化点
  1.slider keepalive包裹router标签 不会重复发请求
  2.定时器要记得销毁
  操作点：封装API->recomand.js--getDisclist函数(用于请求推荐歌单列表数据)
  反向代理获取接口数据的操作 由于vuecli3.0与2.0的不同 导致暴露了各种问题
  express的问题 webpack的问题等等 后台反向代理发起请求
  4-8：先暂时套用接口数据 调用数据操控数据才是重点
  歌单推荐组件部分图片块多出3px原因未知 文字块高度与图片块不一致导致无法平行 原因未知 不使用rem 原因未知 flex黑科技？
  4-9：封装一个简单的scroll组件 监听传递进来的数据 变化之后才随之刷新 否则会出现无法滚动的结果
    但仍然遇到了无法滚动鼠标滚轮可以滚动？ NMD wsm？ 随后发现是缓存问题- -
    百度之后发现的第一个坑：使用scroll组件后 父组件定位方式必须是fixed 子类（即scroll组件div）必须是overflow：hidden height也要设定：100% 另外在钩子函数中初始化以及watch监听数据的方法真的很拥有 应该可以在destroy函数中销毁定时器来提高性能
  4-10：
  为什么scroll组件传递的是dataClist？ 因为这个接口响应速度比另一个快 由于接口响应是个异步的过程
  如果想使用计算属性来监听这两个数组的变化刷新 实际是有个坑的 因为这个slider组件高度是由图片撑开的
  数据是拿到了但是并不会知道图片是何时渲染出来的 如果图片未渲染出不刷新的话会导致scroll组件高度不对
  导致无法滑到底部（少的就是这张图的高度）所以要监听图片的load事件 当载入完成时调用refresh函数对sroll组件进行刷新（高度的刷新）
  而这里有个疑问就是this.checked不是data作用域的 也没用命名过 也可以直接生成直接调用吗 还是说ES6的函数或者说Vue支持直接生成一个暂时的变量 并且不挂载到data域中实时刷新
  这里是一个优化的技巧 只渲染或者说只调用一次的技巧
  4-11：
  better-scroll的渲染原理：调用的时候一定要保证这个dom是渲染完成的 如果变化了一定要refresh
  优化：首屏加载一部分  剩余的懒加载 vue-lazyload
  needsclick better-scroll与fast-click冲突的时候需要设置这个classname让fastclick放全
  4-12：loading组件的开发 于recommend组件中使用 感觉上面的轮播图也可以这样用
  2/10/0.33
  暂时做一个小小总结
  做了的事情 html/css/js层面
  数据获取：后端反向代理获取接口数据
  数据使用：使用v-for等指令渲染数据
  视觉交互：使用better-scroll插件封装了scroll组件 实现了定屏滚动
  性能优化：使用lazyload懒加载技术 减少首屏http的请求
  用户体验：loading组件的封装提高用户体验
  初次跳坑：稍微写一下X-mind和推荐页面的总结吧 然后提交一下
  2/11
  5-1-2
  获取了歌手信息列表的接口数据 奇怪的是 现在已经无法探测到这个接口了
  由于是jsonp的接口与上面的推荐一样需要写参数 只是很奇怪的是不能直接访问
  只能用服务器来取接口吗 = =现在渲染页面第一件事是获取接口了
  接口获取到了才能布局
  另外 如何调用使用接口来的数据 对数据的使用和截取
  2/12
  5-3:标准化接口而来的数据 改成适合我们的数据结构
  对象的遍历是无序的 要变成一个有序的数组
  map 对象 数据排序 排序算法来了
  首先需要复习一下 新的数据结构map set array
  其次是要复习一下操作数组的各类内置方法 这块初级算法有涉及
  暗示单词 
  map是数据的抓取 存储
  后续转移数组是数据的 运算
  返回数组则是 输出数据
  程序 安排上了
  数据处理 charAtCode来进行ABCD的排序 这是正则的使用吧
  2/13
  5-4listView组件
  犯下的低级错误
    1：组件位置改变后 引入的相对路径也会变化 所以最好改成绝对路径就不会这么多事了 这是前期工作
    2：上面的数组拼接数组忘记返回了导致是个空值
    3：V-for调用的数据渲染输出 以及flex布局真是太好用了
    4：需要书写一个pc页面并对仪器进行检测转为对应的移动端页面是那个meta我忘记了
    完成了：页面一部分的htmlcss结构和数据接入 动态交互效果好像没这么做 这里似乎都没做手势的对应交互
    接着不要忘记使用懒加载 因为在入口文件使用了v-lazy 所以可以直接用
  5-5右侧入口的实现 其实比较重要的是上面的搜索匹配 而去哪儿教程还使用了vuex做状态管理 
  数据倒了全局
  DOM操作需要回去看看js高程的基础知识了太久没看了 以前的公用组件也需要封一下了
  2/14
  手势切换路由？
  我觉得可以模仿去哪儿网那样做一个搜索的功能
  1：左侧的列表渲染输出
  2：交互 完成触碰后滑到相应的位置 封装一个dom函数用于获取index（index用于确认点到的是第几个字符串 根据字符串确认位置并跳转）
  这里有个有意思的知识点 就是在created创建的data 以及在同组件不同函数如何传递数据的方法 全局变量
  scroll组件内的两个函数
  touchmove感觉还少了个离开的判定  判定在哪里离开后再次滑动
  获取索引 用于获取dom 再获取指定的y轴 最后在scoll过去
  5-6
  两端列表联动 左侧滑动的位置对应右边的位置 如何实现？ 这个不就是楼梯滚动效果吗..
  需要一个符号用于区分哪些是子组件派发给父组件的 计算属性多看一下了
  scroll基础组件添加了一个listenscroll事件 用于接受父组件的数据来判定是否监听滚动 滚动则分发数据给父组件 即滚动的高度 为负数
  父组件监听这个滚动的高度 与数组内已经得到的 各个group的高度做对比 来判定这个组件位于哪个group的区间 并得到索引值
  再用索引值来与每个字母item的index对比 相等则加上样式
  listview组件新传递了参数probe-type（数字类型） 告知子组件是否需要实时刷新
  函数：封装了一个获取所有高度的函数
  数据：this.listHeight = [] //
        this.listenScroll = true
        新增加
  每次提交应注明某些数据 某些函数 某些功能是哪个时间点添加 完成了什么功能
  5-7
  这只是第一次 还有总结的第二次 封装的第三次
  2/16
  6-2
  子路由本质不是链接跳转 而是一个图层直接盖上去 所以速度才那么快
  子路由的配置
  公用组件的指责在于传递信息和数据 不参与业务逻辑的书写
  singer-detail组件的简单书写
  listview组件的编辑 派发了一个点击事件出去 emit
  6-3：Vuex 各个组件状态管理
  Vuex 头疼 建议重写一次orz 主要是机制不是很清楚 commit 未提交
  6-5 又是接口的抓取 数据的处理 后台接口数据处理为前端需要的数据 再根据数据渲染
  到页面 再根据数据是否与其他组件页面共通来使用数据交互
  6-6： Song类的构成 用于存储歌曲参数
  过滤器 后端接口产生的字段返回给前端不一定所有数据都有用
  必须过滤掉一些非空字段 后端设定为空对象都比没有值要好
  图片上传裁剪插件
  如何给已知对象新增加一组数据
  给一个复合对象内所有子对象呢
  6-7:音乐播放源接口的获取是真的困难以及需要抓取 数据的调用操控过滤 总算会一些了
  song.js创建一个song类来存放各类数据 写入一个fliter函数用于过滤Vuex全局传递的歌手数据 如果没有歌手则不压入数组
  获取到数据后再进行过滤筛选 再结构赋值 再遍历每一项压入数组中 数组中每一个都是song对象
  我学到了什么：值得思考 还要这边的组件构建完才知道

6-8
  muslic-list组件第一部分开发完成
  主要涉及到的是数据//由singer-detail组件传递给子组件使用
    title/关联歌手名  
    bgImage/关联 这里使用了计算属性来获取 原因是？
    Songs/估计是为了传递给子组件 那什么时候使用Vuex全局传递呢
6-9
Songs-list组件第一部分开发
接收songs数据 把里面的歌曲名 歌手 /介绍 文字资源加载 样式还少一部分没加载
music-list组件第二部分开发 使用scroll组件 但是这里的Z-index不大对 动态设定了Z-index的top值来应对各个设备的不一样
在DOM加载完毕后获取背景图片的高度 这里果然选择的是padding-top撑开来来占位 根据背景图片的高度不同来抓取dom设定
有所区别的是 组件的dom必须要抓取$el.属性  才能获得DOM 仅仅只有$this.refs.ref不行 $this.refs.ref.$el.style[]
Songs 还真是传递给songs-list组件的
gitFolw的规矩还是要看一下的 感觉
6-10动画的制作 载入动画没成功 一会看看是不是书写错了
用bg-layer图层把背景层顶上去？是修改bglayer的偏移值 盖在背景层
造成了堆叠布局的错觉 其实并没有 让之随之变动
先做好数据接收和传递的工作 实现原理是 监听歌词列表滚动的距离来对bg-layer进行Y轴偏移盖住bg-image层来达到骗眼的效果 跟网易云的区别点就在于顶部留模糊图片 网易云没有 
滚动距离数据来源：传入listenScroll参数和Pro参数告知需要实时监听 通过scroll的分发机制得到滚动的pos.y值 再存储到data域中作为后续watch侦听器的数据依赖 对滚动距离进行实时的异步监听
获取距离之后操作DOM对bglayer的transfrom属性操控 其中 最大便宜距离是图片的距离和设定的距离 因为 bglayer图层的高度只有一个手机那么大 再往上偏移就穿帮了 但还是存在一点小小的问题就是滚动的距离有差距
6-11 因为Z-index的不同 导致歌单列表是在图片层上方
所以监听滚动距离的边界：当滚动达到限制距离的时候 调整背景图的图层 高度
当滚动距离小于限制距离的时候又调整回来
此处仍然是通过操作DOM来完成的 操控paddingTop和height zIndex属性
6-12 对动画做一些优化
边界问题继续 利用filter层做模糊层
6-13 autofix的简单封装 浏览器的能力检测 用于转换浏览器特性的style
6-14 其余部分
back按钮回去 调用router自带的API 路由和数据连接其余网页
随机按钮的填写 绝对定位 居中 图标拉开
7-1 播放器列表
7-2 vuex使用场景 多个组件都可以使用应用
定义Vuex 首先先在state里面定义好最底层的数据 接着在getter当中 映射state里的数据
更类似计算属性依赖于getter  取得数据后
如何处理数据 在mutation里定义 
在mutation定义前 在mutations-typer定义操作名 mutation本义是一个函数
接受两个参数 一个state  一个需要修改的state里的子元素
idnex.js是入口文件 引入定义好的5个文件
7-3
放在APP.Vue文件下 因为不是路由文件
数据派发 数据传递 songlist派发给musiclist
musiclist调用action分发给musicplayer
非业务组件只提供自身所拥有的数据传递出去
songList点击之后派发给musicList组件 musicList接受后得知被点击后
获取使用 调用ACtions改变Vuex内的数据 而Vuex内的数据又与playerList的数据相关
如此就完成了一次数据操控和绑定
songs数据来源于歌手列表请求而来 包含的数据有
7-4播放器基础样式
完成基础的样式结构搭建 绑定相关数据
表现层： 绑定点击事件 通过修改mutation来修改fullScreen状态 Vuex的修改规则 来更改播放器全屏和微型播放器的状态
视觉层：绝对定位与flex布局法配合 不外乎是垂直居中 浮动 百分比自适应
7-5 播放器展开动画 transtion
本质还是CSS3的属性 添加和移出动画过渡属性
这里对顶部和底部标签打了个关键帧 自身本身的属性应该也要算关键帧进去 跟AE里面卡动画帧一样 原本的关键帧 入场动画的关键帧 中间关键帧 出场关键帧 其中的transtion就是对其中的步骤拉曲线
7-6动画函数添加更好的效果
Vue的transtion的动画钩子函数
函数库 animition-keyframe
bug之一 一开始播放器就处于显示状态 已修复 传递数据的问题 源码为何没报错- -
简述一下动画函数的思路
7-7 动画思路的制作 不再是修改style属性 而是依赖于css3的translate来做动画
7-8 播放歌曲功能
要记得追踪数据的来源和变化了 是在什么时候传递的
歌曲播放功能：播放 暂停 上一曲 下一曲 进度条拖动
绑定点击事件通过使用getter来修改数据
1.先完成了current数据出现后的歌曲播放功能 父组件通过传值控制的方法 巧妙的将点击事件传递给了子组件
2.完成了 播放按钮控制歌曲播放的效果 通过绑定click事件来控制 playing数据 使用toggle函数
playing数据通过watch监听器来与audio标签的播放暂停DOM功能绑定在一起
再通过计算属性监听playing的数据 完成播放按钮图标样式的绑定
全局属性playing连接了歌曲的播放与暂停 样式的改变 
用户通过事件驱动来驱动数据 数据再跟dom行为绑定 达到了用户操作dom 完成整个行为
Vue的优势在于省去了其中的DOM抓取和绑定操作
3.控制圆形唱片的旋转 这里的animation的使用是如何使用的？ CSS3复习走一个
4.注意事件冒泡 延生事件委托 
7-9前进播放功能
这个页面的一切都是currentSong这个数据点控制的  currentSong数据又是在state根据currentIndex控制的 所以操作这个代码就可以了 这里的暂停可以慢慢消失吗？
另外要处理边界情况 比如快速点击 就应该注意函数防抖和函数节流
以及点击完之后下一首的播放状态 是否会继承上一首的
以及播放正常
播放加载完毕
7-10 使用一个参数来限定过量点击 这里的自定义事件没有懂。。
1.前进按钮绑定点击事件 触发函数prev和next 控制currentIndex
函数防抖是依靠两个自定义事件绑定来完成 自定义事件通过data域的songready来禁用三个按钮过渡 两个ready函数和error函数没看懂 来自定义一个异步过程 根据这个异步过程来确认什么时候完成 再重新启用
改进后next和prev按钮的写法很有意思 true就不执行 并在最后设定为false 这样就是一个循环
初始 songReady为false 异步加载事件转为true 按钮执行 转为false 再加载为true
7-11 时间与进程
把时间数据处理掉 又是数据处理 date对象
静：HTML与CSS结构完成
动： 数据绑定 两个动态数据 时刻变化的播放时间 固定的播放时长currentSong数据中获取
时刻播放依靠 事件 timeupdate触发 从事件对象中获取数据
数据处理： 时间戳变为分/钟 以及添加0或者其他字符的方法pad封装 好强
7-12 播放进度条
进度条的布局很巧妙 留了一段没有宽度的div来 这里是把进度条通过播放音乐的百分比改变宽度 是单向绑定
7-13 完成手指触摸滑动事件
这里通过派发事件 完成了一次数据双向绑定
行为层 ：用户从触碰 开始滑动 滑动结束 产生的预期结果 进度条的宽度发生对应的变化 歌曲对应着进度条的变化 同时拉动进度条后还需要继续播放
数据层：父子组件传递的只有百分比这个数据层用于作为中间值绑定并修改行为
子组件更多的完成 行为层所触发的结果 仍然是DOM操作级别的
DOM操作 明天记得理一下思路 从DOM获取数据 操控数据 再操控行为上面来 分离开分析就不会乱了
父子组件联系的只有数据
把单页面的操作 和数据传递连接分离分析
7-15 圆形进度条
先是svg的介绍 建立圆圈 svg不熟悉 数据传递倒是很简单 只传递一个固定半径和百分比再次绑定就可以
主要是svg不熟
然后就是组件插槽的思想 提前占位 还有样式的布置 position和表现的确要分开
再是数据传递再控制
7-16切换功能 播放完无法自动播放 播放模式 单曲循环 顺序播放 随机播放
利用audio的end事件 来触发 先监听模式
行为层：点击图标后改变图标的样式
数据层：播放模式放置在全局 使用vuex的getter mutation来获取修改数据
getter获取数据应用后 与样式绑定在一起 通过mode值控制样式 完成单向数据绑定 点击事件改变mode值 完成了行为 控制 数据 数据控制行为 
再就是把playmode数据跟事件绑定起来才能完成真正的数据绑定 现在只是规定
// 关于项目的分析和难点分析 应该把各个页面拆分开 非数据的公共交互功能 数据交互三块去分析
先是静态页面 再是有动态数据的数据页面 事件驱动的模式还是要记住 Vue完成的DOM事情也不能忘
7-17
主要是changeMode函数的继续衍射 当播放模式改变的时候 随之变动的除了样式 还是播放的列表 而播放列表改动后 当前的选中的Index也要随之改变（为了使当前的歌曲不变） 所以数据改变流向是
playMode-》0,1,2 
playList = sequenceList（顺序列表）打乱后写入 
currentIndex(此时选中歌曲在播放列表中的索引)  在播放列表中通过对比每个元素的Id号抓取出对应的索引
再通过vuex的改变模式写入state
currentSong的变动 state.playList[state.currentIndex]
需要注意的watch的机制是只要currentSong有过更新哪怕最后一致都会被触发 所以如果最后没改变最好来个if判定
涉及到的函数 洗牌算法和find findIndex
都是一个查找回调函数 寻找到就会返回 找不到就会undifined 返回符合函数内的筛选要求
而且只会返回第一个符合的元素
Array.find((value,index,function)=>{

})
7-18
完成了播放结束后继续播放下一首的功能 
完成了循环播放功能
目前未完成 播放模式是随机的话下一首的播放 这里的实现方式是列表随机 估计是为了教乱序算法 
但我觉得这里可以通过randomcurrentIndex的方法来做到随机播放 就像网易云一样 用户的列表并没有改变
另外就是应该后期整个弹出框 导出这个时候的播放列表 不过也不难做 就是布局的地方 然后随机播放应该改动
的是此时的播放索引 这个索引又跟当前播放的歌绑定 所以 从逻辑上讲是可行的
后面自己改写的时候试试看
复盘： findIndex方法找不到 arr.length函数找不到 
 第一是书写错误setPlayList set 第二是操作数组的时候没有返回数组 这里还有个问题
 是动了原有数据 这里只是get调用而不应该改变 所以要用slice来操作
操作：
2..getBoundingClientRect()修复点击按钮的bug offsetWidth 几个浏览器数据获取有点忘了
3..随机播放按钮的action写入 传入歌曲列表数据 改变播放模式 保存顺序列表 修改播放列表 写入此时的播放歌曲（歌曲索引）
  数据引入完毕 写入播放器的状态 全屏与播放
  把数据拆开成两块来看 一个是歌曲数据 一个播放器的状态控制
  本质是双向绑定

然后涉及到的知识点JS 
1.模块的引入和导出 import和require的区分
2.数组的复制 数据的深拷贝和浅拷贝
3.浏览器各个视口高度的限定

7-19 7-20歌词数据的处理
对每个数据的对象格式要做一个检测
express转发代理
base64解码
7-19: 利用express转发代理 这里api获取数据的封装 公用方法的封装很需要学习
使用base64解码歌词
使用parse-lyr封装歌词
还有一个就是js 方法里的promise封装
涉及到的知识：正则表达式
promise异步 proxytable转发
7-21 播放器歌词滚动列表
修改了dom结构 把歌词给写了上去 并渲染输出使用滚动组件
通过监听滚动到了第几条line来确定是否滑动 并且歌词要显示高亮
这里data域发生清算
这里的bug 歌词和滚动条并没有得到绑定 应该是播放时间的问题 应该要修复
这三章有点难理解 多复盘几次
7-22
手势滑动 触摸事件
行为层：手势滑动后后边的歌词显示 左边的圆盘隐藏
数据层：使用一个数据来控制下方小圆点的样式 操作dom来控制透明度
最后还是操作了dom
函数层：滑动手势判定- -nmd好难啊 三个阶段来判定用户滑动的阶段
然后做出相应的逻辑  这里的逻辑判定还没理清楚
逻辑判定：根据滑动方向判定左滑还是右滑 根据滑动的百分比来确认滑的地步 做切换动画
点击获取起始位置
移动过程获取终点位置 再动态的使用偏移做动画 
并且计算出滑动百分比
7-24 边界条件
歌曲列表只有一条
请求不到歌词
APP切换前后台 小程序设计的一些点还是值得考量的
7-25 mini播放器细节优化 让他占地方
mixin混入。。来了
mixin：分发组件中一种灵活的复用Vue单文件函数的功能
在mixin函数使用后 该组件将会执行 mixin函数内的一切操作 钩子函数 监听属性 
当数据冲突时 原组件数据优先  两个钩子函数则会变为数组同时进行
Vue-router router-view 
8-1: 路由设定和数据抓取
每个页面涉及到的数据 应该可以连成一张表了
不能再摸了
vue路由跳转：子路由跳转 跳转到其他页面
vue生命周期：
three.js canvas.js
今天的面试题
网络请求相关：
http与https的区别 ：https在http明文协议上多了一层ssl协议 使数据变得更为安全
http与http2的区别： 信道复用
http请求头里包含了什么：请求链接 请求方法 
可以性能优化的点
gulp的打包压缩
contentType
明天 其实应该是今天该复习的点
gulp压缩打包
vuerouter实现页面跳转
基础知识补全
音乐app一集
需要复习的点：
移动端到PC端的转变 rem 视口布局
需要做的 express与mock.js实现前后端分离 最好有例子和项目
vue+elementUI实现后台管理系统 原理的制作
Node.js实现登录之类的鉴定

9-1
完成了排行榜的QQ音乐接口调用
对于写代理转发跨域请求又多了一些熟练度
9-2 对排行榜的数据进行绑定 加入滚动组件和load组件 以及使用lazyload插件
注意mixin的使用
axios的使用跟ajax其实是类似的 区别就是axios是promise没有回调地狱
还有就是写好的API 肯定是要return 数据的 promise.resolve返回一个新的promise对象
父组件调用子组件的方法： 直接$refs.refname.methods方法调用
子组件调用父组件的方法 ： $parent不现实 还是emit这种自定义事件触发比较合适
父组件传值子组件
子组件传值父组件
Vuerouter要尽快看完 后台要搭起来 echarts也是 别看扁我 硬着头皮变强